---
title: "Saying ’Hi!’ Is Not Enough:Mining Inputs for Effective Test Generation"
date: 2022-01-14
description: "Generators of tests fails to reproduce a majority of bugs (see [5]). This is explained by the fact that generator tends at using wrong inputs. For instance, most of generator use random generated values or values from a predefined pool. But this techniques do not obtain good results because programs use domain-specific data formats. Usually, generated inputs tends to not trigger deep codes because they do not pass the sanity-check from the domain. Toffola et al. presents TestMiner, a novel techniques to address this issue. Their technique is to exploit the knowledge inside existing tests (amplification) to generate proper input. This approach is devised into two steps: 1) It extracts existing literals from tests and index them for a quick retrieval; 2) the test generator queries this index for a given method call. The approach first analyze statically the program. It extracts from this analysis input values associated with a context. A context might be anything that can be represented as a bag of words. In their approach, they choose to use the full qualified name of methods. For each literals, the analysis returns a set of call site tuples Sc. A call site tuples is three elements: the qualified names of the type that defines the method called, the name of the method called and the literals used as input. From Sc, they build a bag of word that summarizes the context. They put context into an HashMap. They assign a specific weigh to each word of bags, because some of them are more relevant than others. For instance, we have the following context: ({org, sql, parser}; \"SELECT x FROM y\"). The word sql contains more information about the context than the word org, which is a common package. To leverage this, they compute the term frequency-inverse document frequency for each words. They use a specific Hash function for the indexing: Simhashing, which allows TestMiner to assign similar hash to similar values. TestMiner retrieves string values for a test generator. First, it assign a weight to the query. The used weight function is prioritizing uncommon words. The search algorithm used is the presented by Manku et al. [6]. Named searchSimhash, the algorithm returns a mapping between string and a list of integers. The algorithm selects multiple indices. This is allow to have all indices of string values that differ of a given number of bits from the querried hash. The more this value is high, the more the algorithm returns values. They implement TestMiner in Randoop, a state-of-the-art generator of test in Java [7]. Their implementation is a web server, that allows to modify only one hundred lines of code in Randoop. They learned data from 3,601 Java projects from the Maven Central Repository, which results with 263,276 string values in 37,821 different contexts. They used 40 classes from 18 Java projects to evaluate the effectiveness of tests generated with the help of TestMiner. Then, they generated 10 test suites using only Randoop and Random enhanced with TestMiner, and compare the branch coverage obtained, computed with JaCoCo. It results that using TestMiner with Randoop increase the coverage for thirty classes and decreases it for two classes. On average, the relative improvement is 21%. TestMiner provides results examples that fit real contract such as IBAN, SQL, Network address, or E-mail. TestMiner has an overhead of 55% in time consumption."
draft: false
link: "https://www.conference-publishing.com/list.php?Event=ASE17"
---
