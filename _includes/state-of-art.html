<section class="section projects-section">
    <h2 class="section-title"><i class="fa fa-file-pdf-o"></i>State of Art</h2>
    <div class="intro">
        <p>Quick abstract of some papers</p>
    </div><!--//intro-->
    <!-- <div class="item">
        <span class="project-title"><h4>Alleviating Patch Overfitting with Automatic Test Generation: A Study of Feasibility and Effectiveness for Nopol</h4></span>
        <p>Authors aim at alleviating patch overfitting in test based repair techniques.They define I_bug, the buggy
            input domain; I_patch, the input domain
            on which the patch has an impact and I_correct, the remaining input domain, for which the behavior of the
            program under repair is correct.
            The perfect patch generated by a test based repair technique would be a patch with an input domain equals to
            the buggy input domain, <i>i.e. </i>
            I_bug = I_patch. The overfitting problem is the fact there are two potential in a patch generated by a
            test bases repair technique: 1) the patch does not fix totally the bug; 2) the patch fix the bug but break
            some code
            in another part of the program, <i>i.e. </i> introduce a regression. They define three kinds of
            over-fitting:</p>
        <ul>
            <li>A-overfitting: the patch does not fix totally the bug.</li>
            <li>B-overfitting: the patch fix the bug but introduce a regression.</li>
            <li>AB-overfitting: the patch does not fix totally the bug and introduce a regression.</li>
        </ul>
        <p>Authors devise a techniques, named UnsatGuided that aim at alleviating those three kinds of overfitting. They propose to use
        automatic generated test cases to guide the synthesize of the patch. The intuition is that is a generated test has a contradiction
        with the manually written tests, this generated test encode the bug and expose it. The bug-exposing test, that is how authors call such test,
        is used to enforce constraints in the repair techniques.</p>
        <p>To evaluate UnsatGuided, they use 224 bugs from the Defects4j benchmark. For the repair technique they use Nopol and generated test cases with Evosuite.
            The experiments results with following observations: 1) Overfitting is common in patch generated by test based repair techniques for real buf in real world application;
            2) UnsatGuided alleviate successfully the overfitting in some cases; 3) the time overhead introduce by UnsatGuided is acceptable in most cases.
        </p>
    </div>--><!--//item-->

    <div class="item">
        <span class="project-title"><h4>Constraint-Based Automatic Test Data Generation <a
                href="http://dl.acm.org/citation.cfm?id=126269#"><i class="fa fa-link"
                                                                    aria-hidden="true"></i></a></h4></span>
        <p>
            DeMillo <i>et al.</i> proposed a first attempt to automatically generate test to meet the fault-based
            testing
            criteria. The fault-based testing criteria is to use mutation analysis, <i>i.e. </i> inject seeded fault
            into a program, then exercise the tests. If the tests fails, it kills the mutants and detects the fault. If
            not, there is a potential lack of test data input in the test suite. This lead the testers to produce this
            new test data input. However, this task is tedious and time-consumption, that why, authors proposed a
            technique to generate them.
        </p>
        <p>
            Their techniques is base on a representation algebraic constraints to kill mutants, and then use this
            representation to generate data to kill it. They called their techniques <i>Constraint-based Testing</i>
            (CBT). In order to kill mutants, Generated test data input must makes a difference in the behavior of the
            mutant. They define necessity constraints templates based on mutation operators used, in Mothra. They
            overcome mutant equivalent program, they add constraints on predicate to force mutant programs to have
            different value than original program.
        </p>
        <p>
            In their techniques, constraints are composed by algebraic expression, <i>i.e.</i> variables, parentheses
            and programming language operators. A constraint is a pair of algebraic expression related with one
            conditional operator. A clause is a conjunctive or disjunctive list of constraints. A constraint is a clause
            that represent one test case.
        </p>
        <p>
            The global workflow of their approach is to successively substitute value for a variable in constraints that
            remains consistent with the rest of the clauses. At the begin, all the values are assigned to a domain that
            contains all the possible values. The reduction aims at eliminate expression in the constraints, and reduce
            the domain of each values by substitute variables by values. At each steps they take the variables with the
            smallest domain.
        </p>
        <p>
            They implemented CBT for Fortran 77 programs in a tool named Godzilla. They use the widely use triangle
            classification program TRITYP. They compare generated test by Godzilla to manually written-test cases (in 30
            hours). Godzilla achieve a better mutation score: 99% against 95 for the manually-written test.
        </p>
    </div>

    <div class="item">
        <span class="project-title"><h4>An Approach to Test Data Generation for Killing Multiple Mutants <a
                href="http://ieeexplore.ieee.org/document/4021328/"><i class="fa fa-link"
                                                                       aria-hidden="true"></i></a></h4>
        </span>
        <p>
            Mutation analysis is an approximation of fault detection potential of a test suite. Liu <i>et al.</i> aim at
            generating a "good" test suite. To do so, they devise a techniques that generate test data that kills
            multiple mutants.
            The idea is that for multiple mutant that are the same location, the constraints to reach them are the same.
            They improve Constraint Based Testing (CBT) by introduce their Improved Iterative Relaxation Method IIRM.
        </p>
        <p>
            The approach is based on the observation that mutants at the same location (same-location mutants) have the
            same reachability conditions. The approach use pair-wise test data generation techniques rather than
            symbolic execution. The approach is done in three steps: 1) collect reachability condition during generation
            of mutants; 2) combine same-location mutants reachability conditions; 3) program path formations.
        </p>
        <p>
            To express reachability conditions, Authors use branch predicates, instead of execution paths in CBT. There
            are two main advantages to use branch predicates: 1) there is no need to figure out a path expression to
            represent all the branch predicates; 2) it is no more necessary to figure out all executions path from the
            starting points. They compute reachability condition of each mutant while traversing the parse tree of the
            original program. They push on a stack the branch predicate when the first statement of one block is met,
            and they pop the top element when the last one is met.
        </p>
        <p>
            To combine reachability condition of same-locations mutants, they distinguish two categories of locations:
            1) Several mutation operator can be applied to the location; 2) location with only on mutation operator that
            produce multiple mutants. For the former case, there is no contradiction in there used mutation operators,
            they combine them into one condition by conjunction. For the latter case, there is two mutation operators:
            arithmetic and relational. For arithmetic, there is no contradiction so they combine reachability condition
            by conjunction. For relationel, there is contradiction. There reduce the combination to two conjunctions.
        </p>
        <p>
            Last but not least, they generate the desired test data by using transforming the combined necessity into
            branch predicates. They use existing path-wise test data generation to obtain the desired data, <i>i.e.
            covering the desired path.</i>.
        </p>
        <p>
            They evaluate their approach on 5 JAVA programs, ranging from 5 to 21 statements. They applied 5 most
            frequently mutation operators of their tools, named JUTO. They show that with their approach, they need
            fewer (20% to 40%) less test data to have almost the same mutation score. Less data generated means less
            time consumption.
        </p>
    </div>

</section><!--//section-->